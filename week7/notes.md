# Routing

- React is a single page application
- We have single pages that are dynamically rendered based on the application's state and user interactions.
- Whenever we want to change routes, a fresh index.html renders and hard reloads the page.

# Client side bundle

- The client-side bundle is a JavaScript file that contains all the code needed to run the application in the browser.
- It is generated by a build tool like Webpack and is served to the client when they request the application.
- The bundle is typically minified and optimized for performance.

# Client side routing

- Client-side routing is the process of handling navigation within a single-page application without triggering a full page reload.
- In React, this is typically achieved using libraries like React Router.
- React Router allows us to define routes in our application and render different components based on the current URL.
- We give all the HTML CSS and JS of all the pages once and then gives the user the freedom to route bewteen the pages.

### How can we do client side routing?

- We can do this with the most popular routing library for React, which is react-router-dom.
- We can use react-router-dom to route different components based on the current URL.

```jsx
function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/contact" element={<Contact />} />
      </Routes>
    </BrowserRouter>
  );
}
```

- Above is a basic example of client-side routing in a React application using react-router-dom. It demonstrates how to define routes and render different components based on the current URL.
- The fault with the above way of routing the code using window.location is it does not do client side routing, we can write efficient code by using useNavigate() hook

```jsx
import {useNavigate} from "react-router-dom";
export default function Dashboard() {
  const navigate = useNavigate();
  function handleClick() {
    navigate("/");
  }

  return (
    <div>
      Dashboard
      <button onClick={handleClick}>Click to navigate</button>
    </div>
  );
}
```

- useNavigate hook should be used inside a component.

```jsx
function Appbar() {
  const navigate = useNavigate();
  return (
    <div>
      <button
        onClick={function () {
          // window.location.href = "/";
          navigate("/");
        }}
      >
        Landing Page
      </button>
      <button
        onClick={function () {
          // window.location.href = "/dashboard";
          navigate("/dashboard");
        }}
      >
        Dashboard page
      </button>
    </div>
  );
}

export default App;
```

- Here appbar itself is a component which is rendered in BrowserRouter

```jsx
<BrowserRouter>
  <Appbar />
  <Routes>
    <Route path="/dashboard" element={<Dashboard />} />
    <Route path="/" element={<Landing />} />
  </Routes>
</BrowserRouter>
```

## Lazy Loading:

- We can update the code a little so that React loads the components only when they are needed, rather than all at once. This can improve the performance of our application, especially if we have a lot of components.
- We can achieve this using React's built-in `React.lazy()` function and the `Suspense` component.

```jsx
import React, {Suspense, lazy} from "react";

const Dashboard = lazy(() => import("./components/Dashboard"));
const Landing = lazy(() => import("./components/Landing"));

function App() {
  return (
    <BrowserRouter>
      <Appbar />
      <Routes>
        <Route
          path="/dashboard"
          element={
            <Suspense fallback={<div>Loading...</div>}>
              <Dashboard />
            </Suspense>
          }
        />
        <Route
          path="/"
          element={
            <Suspense fallback={<div>Loading...</div>}>
              <Landing />
            </Suspense>
          }
        />
      </Routes>
    </BrowserRouter>
  );
}
```

- We wrap the component in a `Suspense` fallback to show a loading indicator while the component is being loaded. This improves the user experience by providing feedback that something is happening in the background.
