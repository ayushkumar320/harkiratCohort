# Routing

- React is a single page application
- We have single pages that are dynamically rendered based on the application's state and user interactions.
- Whenever we want to change routes, a fresh index.html renders and hard reloads the page.

# Client side bundle

- The client-side bundle is a JavaScript file that contains all the code needed to run the application in the browser.
- It is generated by a build tool like Webpack and is served to the client when they request the application.
- The bundle is typically minified and optimized for performance.

# Client side routing

- Client-side routing is the process of handling navigation within a single-page application without triggering a full page reload.
- In React, this is typically achieved using libraries like React Router.
- React Router allows us to define routes in our application and render different components based on the current URL.
- We give all the HTML CSS and JS of all the pages once and then gives the user the freedom to route bewteen the pages.

### How can we do client side routing?

- We can do this with the most popular routing library for React, which is react-router-dom.
- We can use react-router-dom to route different components based on the current URL.

```jsx
function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/contact" element={<Contact />} />
      </Routes>
    </BrowserRouter>
  );
}
```

- Above is a basic example of client-side routing in a React application using react-router-dom. It demonstrates how to define routes and render different components based on the current URL.
- The fault with the above way of routing the code using window.location is it does not do client side routing, we can write efficient code by using useNavigate() hook

```jsx
import {useNavigate} from "react-router-dom";
export default function Dashboard() {
  const navigate = useNavigate();
  function handleClick() {
    navigate("/");
  }

  return (
    <div>
      Dashboard
      <button onClick={handleClick}>Click to navigate</button>
    </div>
  );
}
```

- useNavigate hook should be used inside a component.

```jsx
function Appbar() {
  const navigate = useNavigate();
  return (
    <div>
      <button
        onClick={function () {
          // window.location.href = "/";
          navigate("/");
        }}
      >
        Landing Page
      </button>
      <button
        onClick={function () {
          // window.location.href = "/dashboard";
          navigate("/dashboard");
        }}
      >
        Dashboard page
      </button>
    </div>
  );
}

export default App;
```

- Here appbar itself is a component which is rendered in BrowserRouter

```jsx
<BrowserRouter>
  <Appbar />
  <Routes>
    <Route path="/dashboard" element={<Dashboard />} />
    <Route path="/" element={<Landing />} />
  </Routes>
</BrowserRouter>
```

## Lazy Loading:

- We can update the code a little so that React loads the components only when they are needed, rather than all at once. This can improve the performance of our application, especially if we have a lot of components.
- We can achieve this using React's built-in `React.lazy()` function and the `Suspense` component.

```jsx
import React, {Suspense, lazy} from "react";

const Dashboard = lazy(() => import("./components/Dashboard"));
const Landing = lazy(() => import("./components/Landing"));

function App() {
  return (
    <BrowserRouter>
      <Appbar />
      <Routes>
        <Route
          path="/dashboard"
          element={
            <Suspense fallback={<div>Loading...</div>}>
              <Dashboard />
            </Suspense>
          }
        />
        <Route
          path="/"
          element={
            <Suspense fallback={<div>Loading...</div>}>
              <Landing />
            </Suspense>
          }
        />
      </Routes>
    </BrowserRouter>
  );
}
```

- We wrap the component in a `Suspense` fallback to show a loading indicator while the component is being loaded. This improves the user experience by providing feedback that something is happening in the background.

## Prop Drilling:
- We should push down the state variables as low as possible in the component tree.
- As if the state changes, it will only re-render the components that depend on that state, rather than re-rendering the entire component tree.
- We will store the states in Least Common Ancestor (LCA) of the components which depends on the state.
```jsx
import {useState} from 'react';
function App() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <Count count = {count} setCount={setCount}/>
    </div>
  )
}

function Count(props) {
  return <div>
    Count: {props.count}
    <Buttons setCount={props.setCount} count={props.count}/>
  </div>
}

function Buttons(props) {
  return <div>
    <button onClick = {function() {
      props.setCount(props.count + 1);
    }}>Increase</button>
    <button onClick = {function() {
      props.setCount(props.count - 1);
    }}>Decrease</button>
  </div>
}

export default App;
```
- In above code, the component Buttons need the props of `setCount` and `count` to function properly.
- But we are calling Buttons in Count component, so count componenet needs to accept setCounter as a prop which it sends it down to Buttons. `<Count count = {count} setCount={setCount}/>`
- This is called prop drilling.
- We use `Context API` to avoid prop drilling.

## Context API:
- The Context API allows us to create a context object that can hold state and be accessed by any component within its provider.
- This eliminates the need to pass props down through every level of the component tree, thus avoiding prop drilling.
- We can create a context for our count state and provide it at a higher level in the component tree.
- We can teleport the state variables directly to the components that need them avoiding verbose prop drilling.
- Context API lets us to to keep all the state logic outside core code.

- First we create a context object using `React.createContext()` and provide it at a higher level in the component tree.
- Generally we do it in a separate js file
```jsx
  // In a context.js file
  import {createContext} from "react";

  const CounterContext = createContext(0);

  export default CounterContext;
```

- Now in the main file, we declare the context provider and wrap our component tree with it.
```jsx
  import CounterContext from "./context";
  const [counter, setCounter] = useState(0);
  function App() {
    return (
      <div>
        <CounterContext.Provider value={{counter, setCounter}}>
          <Count />
        </CounterContext.Provider>
      </div>
    );
  }

  // Now if we want to use the state variable in any of the component, we can directly pass or teleport it to that component, without prop drilling which makes the code more readable.
  
  // Notice we are not sending any Prop in the Count
  function Count() {
    const {counter, setCounter} = useContext(CounterContext);
    // Now we have access to the counter and setCounter (state variables)
    return (
      <div>
        <p>Count: {counter}</p>
        <button onClick={() => setCounter(counter + 1)}>Increase</button>
        <button onClick={() => setCounter(counter - 1)}>Decrease</button>
      </div>
    );
  }
```